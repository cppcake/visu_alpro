keys,en,de
BUK_CONT,bucket_count,bucket_anzahl
OCCU_FACT,occupancy_factor,belegungsfaktor
HT_INS,"// Check [b]if[/b] resizing is needed based on occupancy factor\nfloat occupancy_factor = [b]([/b]float[b])[/b]size / [b]([/b]float[b])[/b]bucket_count;\n[b]if[/b] [b]([/b]occupancy_factor >= 0.75[b])[/b] [b]{[/b]\n    resize[b]([/b]2[b])[/b]; // Double the hashtable size\n[b]}[/b]\n\n// Calculate hash [b]and[/b] determine bucket index\nsize_t hash = hashfkt[b]([/b]key[b])[/b];\n[b]int[/b] bucket_index = hash % num_buckets;\n\n// Insert the hash-key pair [b]int[/b]o the appropriate bucket\nbuckets[lb]bucket_index].push_back[b]([/b]std::make_pair[b]([/b]hash, key[b])[/b][b])[/b];\nsize++;\n\n[b]return[/b];\n","// Überprüfe ob eine Vergrößerung der Hashtabelle notwendig ist\nfloat belegungsfaktor = [b]([/b]float[b])[/b]size / [b]([/b]float[b])[/b]bucket_anzahl;\n[b]if[/b] [b]([/b]belegungsfaktor >= 0.75[b])[/b] [b]{[/b]\n    resize[b]([/b]2[b])[/b]; // Ver[b]do[/b]pple die Größe der Hashtabelle\n[b]}[/b]\n\n// Berechne den Hash und bestimme den Bucket-Index\nsize_t hash = hashfkt[b]([/b]key[b])[/b];\n[b]int[/b] bucket_index = hash % num_buckets;\n\n// Füge das Hash-Key-Paar in den entsprechenden Bucket ein\nbuckets[lb]bucket_index].push_back[b]([/b]std::make_pair[b]([/b]hash, key[b])[/b][b])[/b];\nsize++;\n\n[b]return[/b];\n"
HT_RM,"// Check [b]if[/b] resizing is needed based on occupancy factor\nfloat occupancy_factor = [b]([/b]float[b])[/b]size / [b]([/b]float[b])[/b]bucket_count;\n[b]if[/b] [b]([/b]occupancy_factor <= 0.25 [b]and[/b] bucket_count > 1[b])[/b] [b]{[/b]\n    resize[b]([/b]0.5[b])[/b]; // Slice hashtable in hallf [b]([/b]autsch[b])[/b]\n[b]}[/b]\n\n// Berechne den Hash und bestimme den Bucket-Index\nsize_t hash = hashfkt[b]([/b]x[b])[/b];\n[b]int[/b] bucket_index = hash % num_buckets;\n\n// Remove the hash-key pair from the appropriate bucket [b]if[/b] possible\n[b]if[/b] [b]([/b]buckets[lb]bucket_index].remove[b]([/b]std::make_pair[b]([/b]hash, x[b])[/b][b])[/b][b])[/b] [b]{[/b]\n    // Decrement size [b]if[/b] removal was successful\n    size--;\n[b]}[/b]\n\n[b]return[/b];\n","// Überprüfe, ob die Hashtabelle halbiert werden muss\nfloat belegungsfaktor = [b]([/b]float[b])[/b]size / [b]([/b]float[b])[/b]bucket_anzahl;\n[b]if[/b] [b]([/b]belegungsfaktor <= 0.25 [b]and[/b] bucket_count > 1[b])[/b] [b]{[/b]\n    resize[b]([/b]0.5[b])[/b]; // Halbiere die Hashtabelle [b]([/b]autsch[b])[/b]\n[b]}[/b]\n\n// Berechne den Hash und bestimme den Bucket-Index\nsize_t hash = hashfkt[b]([/b]x[b])[/b];\n[b]int[/b] bucket_index = hash % num_buckets;\n\n// Entferne das Hash-Key-Paar aus dem entsprechenden Bucket, falls möglich\n[b]if[/b] [b]([/b]buckets[lb]bucket_index].remove[b]([/b]std::make_pair[b]([/b]hash, x[b])[/b][b])[/b][b])[/b] [b]{[/b]\n    // Dekrementiere size, falls das Entfernen erfolgreich war\n    size--;\n[b]}[/b]\n\n[b]return[/b];\n"
HT_ENTER_KEY,Input: string s to insert/remove,Eingabe: String s zum einfügen/entfernen
HT_H2,"h_2(s): s[0] if |s| > 0, 0 else","h_2(s): s[0] falls |s| > 0, 0 sonst"
HT_H3,h_3(s): The average character of s,h_3(s): Der durchschnittliche Buchstabe von s
HT_H4,h_4(s): The sum of all characters of s modulo 2⁶⁴,h_4(s): Die Summe der Buchstaben von s modulo 2⁶⁴
HT_FT,Hashfunction,Hashfunktion
